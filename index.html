<html>
<head>
  <title>Happy Valentine's Day</title>
  <script type="text/javascript" src="https://code.jquery.com/jquery-3.2.0.min.js"></script>
</head>
  <body>
  
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@v0.182.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.182.0/examples/jsm/",
	"FBXLoader": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/loaders/FBXLoader.js"
  }
}
</script>
    <script type="module">

      import * as THREE from './three.module.js';
	  import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
      let container, stats, hex;
      let camera, scene, renderer;
      let group;
      let targetRotation = 0;
      let targetRotationOnPointerDown = 0;
      let pointerX = 0;
      let pointerXOnPointerDown = 0;
      let windowHalfX = window.innerWidth / 2;
      let textMesh1, textMesh2, textGeo, materials;
      let firstLetter = true;
      let text = "", font = undefined, bevelEnabled = true, fontWeight = "bold";
      let fontName = "optimer"; // helvetiker, optimer, gentilis, droid sans, droid serif
      const tHeight = 20, tSize = 70, tHover = 30, curveSegments = 4, bevelThickness = 2, bevelSize = 1.5;

      const fontMap = {

				"helvetiker": 0,
				"optimer": 1,
				"gentilis": 2,
				"droid/droid_sans": 3,
				"droid/droid_serif": 4

			};

			const weightMap = {

				"regular": 0,
				"bold": 1

			};

      const reverseFontMap = [];
			const reverseWeightMap = [];

			for ( const i in fontMap ) reverseFontMap[ fontMap[ i ] ] = i;
			for ( const i in weightMap ) reverseWeightMap[ weightMap[ i ] ] = i;
			let fontIndex = 1;


      init();
      animate();

      function decimalToHex( d ) {

				let hex = Number( d ).toString( 16 );
				hex = "000000".substr( 0, 6 - hex.length ) + hex;
				return hex.toUpperCase();

			}

      function init(){
        container = document.createElement('div');
        document.body.appendChild(container);


        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        camera = new THREE.PerspectiveCamera
		(50, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 150, 600);
		camera.lookAt(50, 150, 0);
        scene.add(camera);
        const light = new THREE.PointLight(0xfffffff, 0.8);
        camera.add(light);

        const hash = document.location.hash.substr( 1 );

        if(hash.length !== 0){
          const colorhash = hash.substring(0,6);
          const fonthash = hash.substring( 6, 7 );
					const weighthash = hash.substring( 7, 8 );
					const bevelhash = hash.substring( 8, 9 );
					const texthash = hash.substring( 10 );

          hex = colorhash;

					fontName = reverseFontMap[ parseInt( fonthash ) ];
					fontWeight = reverseWeightMap[ parseInt( weighthash ) ];

					bevelEnabled = parseInt( bevelhash );

					text = decodeURI( texthash );
        }

       materials = [
					new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front
					new THREE.MeshPhongMaterial( { color: 0xffffff } ) // side
				];

        group = new THREE.Group();
        group.position.x = 50;
        group.position.y = 150;
        scene.add(group);

        const textureLoader = new THREE.TextureLoader();

		textureLoader.load("./bg1.jpg", (texture) => {
			texture.colorSpace = THREE.SRGBColorSpace;
			scene.background = texture;
		});

        function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {

					// flat shape with texture
					// note: default UVs generated by THREE.ShapeBufferGeometry are simply the x- and y-coordinates of the vertices

					let geometry = new THREE.ShapeBufferGeometry( shape );

					let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide } ) );
					mesh.position.set( x, y, z - 175 );
					mesh.rotation.set( rx, ry, rz );
					mesh.scale.set( s, s, s );

					geometry = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );

					mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color } ) );
					mesh.position.set( x, y, z - 75 );
					mesh.rotation.set( rx, ry, rz );
					mesh.scale.set( s, s, s );
					group.add( mesh );


				}

        function addLineShape( shape, color, x, y, z, rx, ry, rz, s ) {

					// lines

					shape.autoClose = true;

					const points = shape.getPoints();
					const spacedPoints = shape.getSpacedPoints( 50 );

					const geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
					const geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints( spacedPoints );

					// solid line

					let line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );
					line.position.set( x, y, z - 25 );
					line.rotation.set( rx, ry, rz );
					line.scale.set( s, s, s );
					group.add( line );

					// line from equidistance sampled points

					line = new THREE.Line( geometrySpacedPoints, new THREE.LineBasicMaterial( { color: color } ) );
					line.position.set( x, y, z + 25 );
					line.rotation.set( rx, ry, rz );
					line.scale.set( s, s, s );
					group.add( line );

					// vertices from real points

					let particles = new THREE.Points( geometryPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
					particles.position.set( x, y, z + 75 );
					particles.rotation.set( rx, ry, rz );
					particles.scale.set( s, s, s );
					group.add( particles );

					// equidistance sampled points

					particles = new THREE.Points( geometrySpacedPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
					particles.position.set( x, y, z + 125 );
					particles.rotation.set( rx, ry, rz );
					particles.scale.set( s, s, s );
					group.add( particles );

				}


				const iPts = [];

				iPts.push( new THREE.Vector2( 610, 320 ) );
				iPts.push( new THREE.Vector2( 610, 1000 ) );
				iPts.push( new THREE.Vector2( 450, 1000 ) );
				iPts.push( new THREE.Vector2( 450, 320 ) );

				for ( let i = 0; i < iPts.length; i ++ ) iPts[ i ].multiplyScalar( 0.25 );

				const iShape = new THREE.Shape( iPts );

        //Heart
        const x = 0, y = 0;

        var fontLoader = new THREE.FontLoader();

        fontLoader.load( './helvetiker_bold.typeface.json', function ( font ) {

          var textGeo = new THREE.TextGeometry( "MIRANDA", {

            font: font,

            size: 75,
            height: 50,
            curveSegments: 12,

            bevelThickness: 2,
            bevelSize: 5,
            bevelEnabled: true

          } );

          var textGeo2 = new THREE.TextGeometry("I love you and think you're rad <3.",
        {
          font: font,
          size: 20,
          height: 10,
          curveSegments: 12,
          bevelThickness: 1,
          bevelSize: 2,
          bevelEnabled: true
        });

          var textMaterial = new THREE.MeshPhongMaterial( { color: 0x660000 } );

          var mesh = new THREE.Mesh( textGeo, textMaterial );
          var meshtwo = new THREE.Mesh(textGeo2, textMaterial);

          mesh.position.set(-250, -100, 0 );
          meshtwo.position.set(-250, -150, 20);

          group.add( mesh );
          group.add(meshtwo);

        } );

				const heartShape = new THREE.Shape() // From http://blog.burlock.org/html5/130-paths
					.moveTo( x + 25, y + 25 )
					.bezierCurveTo( x + 25, y + 25, x + 20, y, x, y )
					.bezierCurveTo( x - 30, y, x - 30, y + 35, x - 30, y + 35 )
					.bezierCurveTo( x - 30, y + 55, x - 10, y + 77, x + 25, y + 95 )
					.bezierCurveTo( x + 60, y + 77, x + 80, y + 55, x + 80, y + 35 )
					.bezierCurveTo( x + 80, y + 35, x + 80, y, x + 50, y )
					.bezierCurveTo( x + 35, y, x + 25, y + 25, x + 25, y + 25 );

          const extrudeSettings = {depth: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1};
		  
		  const mdloader = new FBXLoader();
		mdloader.load(
		"./heart.fbx",
		(obj) => {
			obj.scale.setScalar(0.01);
			obj.position.set(50, 150, 0);    
			scene.add(obj);
			renderer.render(scene, camera);
		},
		(xhr) => console.log(`${(xhr.loaded / xhr.total * 100).toFixed(1)}% loaded`),
		(err) => console.error(err)
      );

          addShape( iShape, extrudeSettings, 0xf08000, -250, -90, 100, 0, 0, 0, 1 );
          addShape(heartShape, extrudeSettings, 0xf00000, 80, 100, 100, 0, 0, Math.PI, 1);
		  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
		  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
		  dir.position.set(5, 10, 7);
		  scene.add(dir);

          renderer = new THREE.WebGLRenderer({antialias: true});
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(window.innerWidth, window.innerHeight);
          container.appendChild(renderer.domElement);

          container.style.touchAction = 'none';
          container.addEventListener('pointerdown', onPointerDown, false);
          window.addEventListener('resize', onWindowResize, false);

      }

      function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerDown( event ) {

				if ( event.isPrimary === false ) return;

				pointerXOnPointerDown = event.clientX - windowHalfX;
				targetRotationOnPointerDown = targetRotation;

				document.addEventListener( 'pointermove', onPointerMove, false );
				document.addEventListener( 'pointerup', onPointerUp, false );

			}

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				pointerX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

			}


			function onPointerUp() {

				if ( event.isPrimary === false ) return;

				document.removeEventListener( 'pointermove', onPointerMove );
				document.removeEventListener( 'pointerup', onPointerUp );

			}

      function animate() {

				requestAnimationFrame( animate );

				render();
			}

      function play(){
		//$('#nerve').trigger('play');
		}

			function render() {

				group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
				renderer.render( scene, camera );

			}
    </script>

  </body>
</html>